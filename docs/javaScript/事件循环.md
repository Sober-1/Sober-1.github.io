# 事件循环

js是一门单线程语言，代码的执行过程由上而下依次执行。因此当遇到一些耗时的操作，进程就会被阻塞，下面的代码都将不能执行，如何解决这种情况呢？JavaScript将任务分为了`同步任务`以及`异步任务`。

* **同步任务**指的是，所有任务都在一个进程中，只有执行完上一个任务，才可以执行下一个任务，同步任务一般在主线程执行。
* **异步任务** 指的是不进入主线程，而是通过调用web api先进入**任务队列**进行等待，然后在特定时机进入主线程开始执行。

## 函数调用栈
在我们学习JavaScript的事件循环之前，我们需要先了解一下JavaScript中函数的执行过程。函数的执行过程其实是一个`压栈`的过程。我们可以把`栈结构`比喻成一个桶，我们往里面塞东西，先塞进去的东西被压在下面，如果想把它拿出来，必须把上面的东西全拿出来才能拿最下面的。因此`栈结构`最显著的特点就是`先进后出`。
``` js
console.log('1')

function add(num1,num2) {
    return num1 + num2
}

function result() {
    const res = add(1,2)
    console.log(res)
}

result()
```
这段代码的出入栈顺序是怎样的呢？

![fun](/img/函数栈demo.png)

有人会问？代码中明明是**函数add**定义在**函数result**之前，为什么入栈顺序相反呢？这是因为当函数**未执行的时候**并不会**进入函数栈**。

这段代码的意思其实是这样的，console.log其实也是一个函数，它执行完会立刻出栈，因此上图其实是不需要画console.log的。紧接着，我们定义了add函数和result函数，这时我们并没有执行这两个函数，因此这两个函数也未入栈。接下来我们**执行了result函数**，result函数入栈，**开始执行result函数**，在result函数内部**执行了add函数**，此时**add函数入栈**，**开始执行add函数**，执行完毕后，**add函数出栈**，紧接着**执行result函数**剩下的代码，打印出res，**result函数执行完毕并出栈**，此时函数栈清空，执行完毕所有函数。这就是`函数压栈`的过程，先进后出。

::: tip
`主线程`上的函数就是通过`函数栈`的方式来执行的。
:::

## setTimeout
* setTimeout执行时也会被**压入函数栈**，进入函数栈后会**马上弹出函数栈**。
* setTimeout不会阻塞后续代码的执行，原因就是**浏览器的事件循环**。

问题来了，既然setTimeout进入函数栈后立马出栈，那么它的**回调函数**什么时候执行呢？
``` js
setTimeout(() => {
    console.log('setTimeout回调')// ? 何时执行
}，1000) 
```
* 假如我们称**setTimeout**的回调函数为`timer`，那么在合适的时机(比如我们设置的回调时间为1000毫秒)调用浏览器内部的web api，将`timer`加入到**任务队列**(Event Queue)。
* **任务队列**中存放的函数**先进先出**，轮到谁执行的时候，会将它们**放入主进程的函数调用栈中**，在调用栈中执行。

::: tip
`定时器`、`dom监听`、`ajax请求`的回调函数都会被存放在**任务队列**中。
:::

综上所述，在JavaScript中，同步任务和异步任务分别进入不同的执行环境。**同步任务进行主线程**，**异步任务进入任务队列**，等到**主线程的任务执行完毕后**，会去**任务队列**取出合适时机的任务，将它放入**主线程的函数调用栈**中执行，这个过程就是**事件循环**。

## Promise
**Promise**对象的**回调函数的函数体**会在**主进程**执行的时候同时执行，但是`Promise.then`,
`Promise.catch`，`Promise.finally`，`Promise.resolve()`，`Promise.reject()`会被加入到任务队列中执行。

## async
* async会做什么呢？函数之前加上async关键字，函数的返回值就会隐式的返回一个**promise对象**，如下代码：
``` js
async function test() {
    return 'test'
}

console.log(test())  // Promise {<fulfilled>: "test"}
```
可以看到，当函数test加上async关键字时，返回值会被Promise对象包裹。

### await是什么？
* await关键字只能在带有async关键字的函数内部使用，在外部使用时会报错。
* **await** 表示的是 **等待** , await等待的是右侧的[表达式结果]，如果右侧是一个函数，等待的是右侧函数的返回值，如果右侧的表达式不是函数则直接是右侧的表达式。await在等待时会让出线程阻塞后面的执行。await的执行顺序为从右到左，会阻塞await语句后面的代码执行，但并不是直接阻塞await的表达式。
``` js
// await后跟函数
async function test() {
    let res = await test1() // 不会阻塞test1的执行
    console.log('test') // 会阻塞
}

function test1() {
    console.log('test1')
}

test()  // test1 => test
```
当await后**跟一个函数时**，await会**等待函数的返回值**，因此，test1函数不会被阻塞，会进入主线程执行，之后的任务被加入**任务队列中**。
``` js
async function test() {
    let res = await 3
    console.log(res)
    console.log('test')
}

function test1() {
    console.log('test1')
}

test1()
console.log(1)

test()

// 输出：test1 => 1 => 3 => test
```
我们可以发现，当await后跟的**不是一个函数时**，await会立马**让出线程**，先让后边的同步代码执行，将**await语句之后，async函数中剩下的任务放入任务队列**。

在ES最新的标准中，**await**和**Promise.resolve()**语义一致。

``` js
async function test() {
    let res = await 3
    console.log(res)
}

// 等价于

async function test1() {
    Promise.resolve(3).then(res => {
        console.log(res)
    })
}
```
从这里我们可以理解，**await**后跟的内容，其实是作为**resolve的参数**，传入到**Promise.then()中**，因此它不会被阻塞，而**执行完await**之后的内容，即let res = await 3 下面的 console.log(res)其实相当于在**Promise.then()中执行**，因此会被加入**任务队列。

既然这样我们就可以这么来理解，**await后的函数**我们可以把它当做**Promise的回调函数的主体**，**不会加入到任务队列**，会**立即执行**，而**await那一句代码之后的函数**，相当于**Promise.then()包裹的内容**，会被加入到任务队列，**异步执行**。

## 宏任务和微任务
任务队列并**不是只有一个队列**，它可以细分为**宏任务队列(macrotask queue)**和**微任务队列(microtask queue)**。

* **宏任务队列**常见的有`DOM的监听`，`setTimeout`，`setInterval`，`ajax`等。
* **微任务队列**常见的有`Promise`，`queueMicrotask()`等。

宏任务队列和微任务队列的执行顺序又是怎样的呢？

1. 执行**微任务队列**，将**微任务队列**中的任务执行完毕。
2. 执行**宏任务队列**，执行完**宏任务队列中的第一个任务**。
3. 查看**微任务队列是否有新加入的微任务**。
4. 如果**没有新增**，继续执行**宏任务的下一个任务**，如果**微任务队列有新增任务**，继续执行**微任务队列中的所有任务**。
5. 重复**步骤3和步骤4**。
6. 执行完毕任务队列中所有任务。

我们来通过一段代码来体验一下**事件循环**以及**任务队列**。
``` js
setTimeout(() => {
    console.log('set1')
    new Promise(resolve => {
        resolve()
    }).then(() => {
        new Promise(resolve => {
            resolve()
        }).then(() => {
            console.log('then4')
        })
        console.log('then2')
    })
})

new Promise(resolve => {
    console.log('promise1')
    resolve()
}).then(() => {
    console.log('then1')
})

setTimeout(() => {
    console.log('set2')
})

console.log('log')

// 自定义微任务
queueMicrotask(() => {
    console.log('queueMicrotask')
})

new Promise(resolve => {
    resolve()
}).then(() => {
    console.log('then3')
})
```
我们来看一下上述代码的执行过程：
1. 执行setTimeout函数，回调函数(set1)放入宏任务队列
2. 执行new Promise，因为promise回调函数的主体会放入主进程执行，因此打印出**promise1**，
接下来执行resolve()，进入promise.then，promise.then的回调(then1)被放入微任务队列
3. 执行setTimeout函数，回调函数(set2)放入宏任务队列
4. 执行console.log函数，进入主进程，打印出log
5. 自定义微任务，微任务(queueMicrotask)进入微任务队列
6. 执行new Promise，执行resolve(),进入promise.then，(then3)被放入微任务队列

至此，我们可以得到此时的情况：

已打印：promise1，log

微任务队列：then1,，queueMicrotask，then3

宏任务队列：set1，set2

继续执行微任务队列中的任务：

1. 执行console.log('then1')，放入函数调用栈打印出then1
2. 执行console.log('queueMicrotask')，打印出queueMicrotask
3. 执行console.log('then3')，打印出then3
4. 微任务执行完毕，开始执行宏任务set1，首先执行console.log('set1')，打印出set1，紧接着执行new Promise，执行resolve，进入promise.then，将new Promise放入微任务队列，此时微任务队列新增了任务，因此会继续执行new Promise，再次调用resolve，将then4加入到微任务队列，此时then2在主线程执行，因此会打印出then2。回头继续执行微任务，打印出then4，微任务队列再次清空，开始执行宏任务。
5. 执行console.log('set2')打印出set2
6. 任务队列执行完毕，代码执行完成

从上述过程可得知最后的结果为 promise1 => log => then1 => queueMicrotask => then3 => set1 => then2 => then4 => set2

