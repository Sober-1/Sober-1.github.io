# 函数

## 定义函数的方式
在`JavaScript`中，我们想声明一个函数有多种方式，但都离不开`function`关键字，`function`代表了这是一个函数

1. 函数声明

&nbsp;&nbsp;格式为`function 函数名 (形参) { 函数体 }`，使用该方法定义函数，会进行`函数声明提升`，哪怕把函数的执行语句写在函数之前，也可以执行。
``` js
test() // 输出 test

function test() {
  console.log('test')
}
```

2. 函数表达式

&nbsp;&nbsp;格式为`var 变量名 = function(形参) { 函数体 }`，这种定义函数的方法必须等到`JavaScript`引擎执行到当前行的时候，才会解析函数表达式，因此函数的执行语句不能放在`函数表达式之前`。
``` js
test() // 输出 test is not a function

var test = function() {
  console.log('test')
}

test() // 输出 test
```
3. 构造函数

&nbsp;&nbsp;格式为`var 函数名 = new Function('形参'，'函数体')` 通过`new Function`来新建一个函数对象，并赋值给变量，变量名称就是函数的名称。
``` js
// 输入
var fun = new Function('name','return name')
console.log(fun('李'))

// 输出  李
```

## 函数的类型

1. 匿名函数: 顾名思义，匿名函数就是没有定义`函数名`的函数。
``` js
// 输入
setTimeout(function() {
  console.log('匿名函数')
}, 1000)

// 输出  1秒后控制台输出 '匿名函数'
```

2. 具名函数：顾名思义，具名函数就是具有`函数名`的函数。

3. 箭头函数：`ES6`新的函数写法，利用`=>`连接形参和函数体，取消了`function关键字`。
``` js
// 输入
var fun = (firstName,lastName) => {
  console.log(firstName + lastName)
}

// 箭头函数的形参如果只有一个，可以省略括号

fun('张','三')

// 输出  张三
```

4. 立即执行函数：格式通常为`(function(形参){函数体})(参数)`或`(function(形参){函数体}(参数))`，想要立即执行函数做到立即执行，要做到两点：

* 该函数必须是`函数表达式`而不能是`函数声明`。
* 函数后必须跟()
``` js
(function(num) {
  console.log(num)    // 使用()运算符 123
})(123)

(function(num) {
  console.log(num)    // 使用()运算符 123
}(123))

!function(num) {
  console.log(num)    // 使用!运算符 123
}(123)

+function(num) {
  console.log(num)    // 使用+运算符 123
}(123)

-function(num) {
  console.log(num)    // 使用-运算符 123
}(123)

*function(num) {
  console.log(num)    // 使用*运算符 123
}(123)

/function(num) {
  console.log(num)    // 使用/运算符 123
}(123)

var a = function(num) {
  console.log(num)    // 使用=运算符 123
}(123)
```

从上述代码我们可知，`!+-*/`等运算符都可以让函数立即执行，这就意味着，无论我们使用哪种运算符，只要将函数写为`函数表达式的形式`并`立即传参调用`，就可以实现立即执行啦。

## 函数中this的指向问题

其实函数的`this指向`说难不难，说易不易，难就难在容易混淆。其实只需记住，谁`调用了该函数`，那么`该函数的this`就指向调用它的对象。
``` js
function test() {
  console.log(this)
}

test() // Window
// test() 其实就等于 window.test() 只不过window被我们省略了

function test1() {
  "use strict" // 开启严格模式
  console.log(this)
}

test1() // undefined

let obj = {
  name: 'obj',
  fn: function() {
    console.log(this.name)
  }
}

obj.fn() // 'obj' 说明此时的this指向obj

let obj1 = {
  name: 'obj1',
  innerObj: {
    name: 'innerObj',
    fn: function() {
      console.log(this.name)
    }
  }
}

obj1.innerObj.fn() // 'innerObj' 说明此时的this指向obj1.innerObj

let obj2 = {
  name: 'obj2',
  innerObj: {
    name: 'innerObj',
    fn: () => {
      console.log(this)
    }
  }
}

obj2.innerObj.fn()  // Window
```

从上述代码我们可知：
* `普通函数`中，`this`指向`被调用的函数所在的对象`，简单点理解，`this`指向`被调用函数的上一级对象`。

* `默认情况下`，如上述代码的第一个例子，`this`指向`Window`对象，在`严格模式`下，`this`是`undefined`。

* `箭头函数`是不绑定`this`的，因此当`箭头函数`作为方法时，`this`永远指向`Window`对象。
