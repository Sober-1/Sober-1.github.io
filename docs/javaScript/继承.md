# 继承

在了解`继承`之前，我们需要了解一些知识。
* 构造函数(constructor): 我们可以通过 **new** 一个构造函数生成新的实例，且该实例会继承来自构造函数的方法和属性。
* 构造函数都有一个属性 **prototype** ，构造函数的实例会继承 **prototype** 上的方法
* 构造函数的 **prototype** 上的 **constructor** 属性，指向的是构造函数本身
* 构造函数的实例上有 **\_\_proto\_\_** 属性，该属性指向构造函数的 **prototype** 
* 原型链：每个对象都有自己的`原型`，原型也有自己的原型，当对象的`原型`不为`null`的话，就可称之为`原型链`。当调用某个对象的方法时，会先在自身的`prototype`上寻找该方法，如果没有就会通过自己的去构造函数的 **原型** 上找，以此类推，直到一个对象的`原型对象`为`null`时还未找到，就会抛出异常。。

::: tip
* 任何函数都可作 **构造函数** ，即任何函数都可以通过 **new** 来创建一个实例。而我们常见的 **构造函数** 的函数名都是以 **大写字母** 开头，这只是一种规范，来说明该函数作为 **构造函数** 来使用。

* JS的继承是基于原型的。
:::

## 冒充继承
这个名字听起来很怪，很难理解，其实很简单，就是让父类的构造函数作为子类的方法，然后调用子类的方法，实现继承。代码如下:

``` js
// 输入
function Parent (name) {
    this.name = name
    this.age = 21
    this.sayAge = function () {
        console.log(this.age)
    }
}

Parent.prototype.sex = '男'

function Child (name) {
  this.parent = Parent
  this.parent(name)

  // 此时执行
  // this.name = name
  // this.age = 21
  // this.sayAge = function() { console.log(this.age) }
  // 这时子类已经继承了所有的父类属性和方法，多了一个this.parent = Parent， 只需删掉
  delete this.parent
  this.test = function () {
    console.log(this.name)
    this.sayAge()
  }
}
let child = new Child('coder')
console.log(child.sex)
child.test()

//输出 undefined coder 21
```
* 优点：可以实现多继承
* 缺点：无法继承父类原型链上的属性和方法

## 原型继承
该方法其实就是将子类的原型对象指向父类的实例，子类通过访问原型链，从而与父类公用方法和属性。
代码如下：
``` js
// 输入
function Parent (name) {
    this.name = name
    this.age = 21
    this.arr = [1,2,3]
}

Parent.prototype.sex = '男'

function Child () {
    this.skill = 'coder'
}

// 将子类的原型对象指向父类的实例
Child.prototype = new Parent('Lee')

// 由于子类的原型指向了父类的实例，因此子类的constructor变成了父类，这显然看起来很奇怪
// 我们手动改变
Child.prototype.constructor = Child
let child1 = new Child()
let child2 = new Child()
console.log(child1.name)
child1.arr.pop()
console.log(child2.arr)

//输出 Lee [1,2]
```
* 优点：做到了属性和方法共享
* 缺点：1. 子类不可以传参  
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp2. 当父类的属性有引用类型的时候,修改任意一个实例的该属性，其它子类都会受到影响。

## 构造函数继承
为了让子类可以自己添加方法和属性，我们可以通过`call`来调用父类的构造函数，从而给每个子类生成独立的属性和方法。

代码如下：
``` js
// 输入
function Parent (firstName,lastName) {
    this.name = firstName + lastName
    this.arr = [1,2,3]
}
function Child (firstName,lastName) {
    // 调用父类并传参
    Parent.call(this,firstName,lastName)
    // 或者使用
    // Parent.apply(this,[firstName,lastName])
}

let child1 = new Child('李','璞')
let child2 = new Child('李','璞')
child1.arr.pop()
console.log(child1.name)
console.log(child2.arr)

// 输出  李璞  [1,2,3]

```
* 优点：子类实例可以传参，实现子类所有属性方法独享，不同实例不会受到影响。
* 缺点：1. 只能继承父类中已经定义的方法，每次增加方法都需要先在父类中定义，复用性不强。  
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp2. 无法继承父类原型链上的属性和方法
## 组合继承
该方法相当于`原型继承`和`构造函数继承`的结合。

代码如下：
``` js
// 输入
function Parent (firstName,lastName) {
    this.name = firstName + lastName
    this.age = 21
    this.arr = [1,2,3]
}

Parent.prototype.sex = '男'

function Child (firstName,lastName) {
    // 调用父类并传参
    Parent.call(this,firstName,lastName)
    // 或者使用
    // Parent.apply(this,[firstName,lastName])

    this.skill = 'coder'
}

// 将子类的原型对象指向父类的实例
Child.prototype = new Parent('张','三')
Child.prototype.constructor = Child
let child1 = new Child('李','璞')
let child2 = new Child('李','璞')
console.log(child1.name)
child1.arr.pop()
console.log(child2.arr)

//输出 李璞 [1,2，3]
```
* 优点：实现子类所有属性方法独享，不同实例不会受到影响。
* 缺点：调用了多次父类构造函数。

## 寄生继承
该继承方式实现的原理就是封装一个**继承过程的函数**，该函数在内部以某种形式来做增强对象，最后返回该对象。这句话优点拗口，具体还是看代码如何实现。
``` js
// 输入
方法一：
    // 封装一个函数，该函数接收一个参数，参数格式为Object，创建一个函数，该函数的原型指向传进的参数对象，最后返回该函数的实例
    function strongObj(obj) {
      function Fun(){}
      Fun.prototype = obj
      return new Fun()
    }
方法二：
    // 在ES5中有一个Object.create(obj)方法， 该方法可以看作是上述方法的封装
    function Child(obj) {
      let child = strongObj(obj)
      // 或
      // let child = Object.create(obj)

      // 再给child增加自身的属性以及方法
      child.age = 21
      child.arr = [1,2,3]
      return child
    }

    let obj = {
      name: '李'
    }

    let child1 = Child(obj)
    let child2 = Child(obj)
    child1.arr.pop()
    console.log(child1.name)
    console.log(child2.arr)

// 输出 李 [1，2，3]
```
* 优点：实现子类所有属性方法独享。
* 缺点：和构造函数继承一样，复用性差。
## 寄生组合继承
无论通过`原型继承`还是`组合继承`亦或是`寄生继承`，都不是完美的，比如在使用`组合继承`的时候，调用了两次父类的构造函数。一次是 **call** ，一次是 **new** 。为了减少一次调用，同时让子类共享父类的方法，我们可以将上述代码的`20`行这样写。
``` js
Child.prototype = Parent.prototype
```
但是问题来了，`Parent.prototype`指向的是一个对象，是引用数据类型，因此，当我们改变`Child.prototype.constructor = Child`的时候，父类构造函数的`constructor`也会改变，如何解决呢？`寄生组合继承`可以帮我们实现，何为`寄生`？其实就是在`Child.prototype`和`Parent.prototype`直接加一层媒介，让它们胡不影响。

而`寄生组合继承`几乎完美的实现了继承，究竟怎么做到的呢？代码如下：
``` js
// 输入
function Parent (firstName,lastName) {
    this.name = firstName + lastName
    this.age = 21
    this.arr = [1,2,3]
}

Parent.prototype.sex = '男'

function Child (firstName,lastName) {
    // 调用父类并传参
    Parent.call(this,firstName,lastName)
    // 或者使用
    // Parent.apply(this,[firstName,lastName])

    this.skill = 'coder'
}

// 将子类的原型对象指向父类的实例
Child.prototype = Object.create(Parent.prototype)

Child.prototype.constructor = Child

let child1 = new Child('李','璞')
let child2 = new Child('李','璞')
console.log(child1.name)
child1.arr.pop()
console.log(child2.arr)

//输出 李璞 [1,2，3]
```
::: tip
  Object.create(obj)方法会创建一个新对象，采用传入对象作为新对象的`__proto__`
:::
通过增加这行代码，会让`Child.prototype`指向`__proto__`为`Parent.prototype`的新对象，通过这个对象让Child的原型和Parent的原型建立联系，但又不指向同一块内存地址，因此改变`Child.prototype.constructor`的时候就不会影响到父类的构造函数。

## Class继承
在ES6中，JS为我们提供了`继承`的`语法糖`，那就是`Class`关键字

`Class`继承中，有几个关键字，分别为`Class`、`constructor`、`super`和`extends`，`Class`代表声明一个`类`，`constructor`就是构造函数方法，而`super`则相当于ES5中`call`或者`apply`的作用，`extends`则代表`继承自`，`类`中除了`构造函数方法`,其它方法都挂载在`类的原型链上`。

### Class继承的写法
``` js
// 输入
class Parent {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  skill() {
    console.log("coder")
  }
}

class Child extends Parent {
  constructor(name, age, sex) {
    super(name, age)
    this.sex = sex
  }

  test() {
    console.log(this.name)
  }
}

let child = new Child('李',21,'男')
console.log(child.age)
child.skill()
child.test()

// 输出 21 coder 李
```

## new 操作符做了什么
通过继承，我们知道 **new** 一个构造函数，可以得到一个实例，那么 **new** 的过程中，JS帮助我们做了什么呢？

``` js
// example
function A(name) {
    this.name = name
}

var a = new A('李')
```

内部帮我们做了：

``` js
// 声明空对象
var a = {}
// 共享原型链方法
a.__proto__ = A.prototype
// 共享属性
A.call(a)
```
::: tip
上述代码我们可知，在 **new** 的时候，内部帮我们最后做了一步`call`的操作，这也是为什么我们说在`组合继承`中，调用了两次父类的构造函数。
:::


**new** 一共帮我们执行了三步操作
1. 声明一个`空对象`
2. 将新对象的`__proto__`指向了`父类的prototype`
3. 将父类的this指针替换成新对象，然后再调用父类
