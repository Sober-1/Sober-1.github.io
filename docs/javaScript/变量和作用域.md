# 变量和作用域

::: tip
在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。

作用域的字面意思就是，代码块只在某一区域起作用。
:::

## 了解 var、let、const

在学习作用域之前，我们首先要了解 js 中常用声明一个**变量**或**常量**的方式。

在 ES6 之前，我们的代码中，声明一个变量的方式，无论是字符串或者是对象等。都是使用 `var 变量名 = xxx` 的格式。直到 **let** 和 **const** 的出现，我们的代码才更加规范起来。

那么它们直接有什么区别呢？

`var`：声明一个**变量**，在该变量被声明之后，可以在下文代码中对该变量进行重新赋值，并**覆盖**原有值。

```js
// 输入
var a = 123;

a = 456;

console.log(a); // 456
```

`let`：声明一个**变量**，和`var`的作用基本一致，不过使用`let`声明的变量，只在**当前块级作用域**可以使用。
`const`: 和`let`基本一致，都是**只在块级作用域生效**，但表示声明一个**常量**，顾名思义，常量代表着不可以被改变的值，一旦被赋值，就不可修改,否则就会抛出异常。

```js
// 输入
const BASE = 1;

BASE = 2;

console.log(BASE); // Uncaught TypeError: Assignment to constant variable.报错
```

::: tip
通常我们的常量都会使用大写字母，多个字符可以用下划线（\_）进行分割，但是在日常开发中，即使是 const 声明的常量，我们也经常会使用小写字母，只需保证该常量不会被以其它方式修改就可以
:::

## 作用域

- 在了解`全局变量`以及`局部变量`之前，我们需要先了解什么是`全局作用域`以及`局部作用域`

### 全局作用域

## 全局变量

- **最外层的函数**以及**在最外层函数外定义的变量**,拥有`全局作用域`,可以称之为**全局变量**。
- 所有没有通过**var**关键字声明的变量都会默认提升为**全局变量**。

```js
var a = 123;

function test() {
  b = 456;
}

function test1() {
  console.log(a);
  console.log(b);
}

test();
test1(); // 123  456
```

通过上述代码我们可知，**b 明明写在函数 test 内**，按理说**b 应该只能在函数 test 局部使用**，但是因为没有**使用 var**关键字，**b 被默认提升为了全局变量**。

## 局部变量

- 声明在**函数内部的变量**，和全局变量相反，局部变量一般只拥有**局部作用域**，最常见的例如函数内部。

```js
var a = 123;

function test() {
  var b = 456;
}

function test1() {
  console.log(a);
  console.log(b);
}

test();
test1(); // 123  b is not defined
```

上述代码我们可知，当使用**var**关键字声明变量 b 的时候，**变量 b 被定义在函数 test 的局部作用域中**，只可在**test 内部访问**，外部无法访问，此时的变量 b 为**局部变量**。

## 全局作用域

- 一个`js文件`或一个`script`标签之中的内容，都可以称之为`全局`，这一块区域之中定义的所有`变量或常量`，都处于**全局作用域**中，这个文件共享某个变量。
- `全局作用域`在**页面打开的时候创建**，在**页面关闭时销毁**。
- 在全局作用域中有一个全局对象 **window**（代表的是一个浏览器的窗口，由浏览器创建），可以直接使用。如我们经常使用的`console`以及`alert`函数，就是`window对象`中的函数。

```js
var a = 123;

function test() {
  console.log(a);
}

function test1() {
  console.log(a);
}

test(); // 123
test1(); // 123
```

从上述例子我们可以看出，当我们在**一个 js 文件中定义了变量 a 的值**，无论是在**函数 test 还是在函数 test1**中都可以访问到 a 的值，并进行打印，因此我们可以知道，定义在全局作用域中的变量，在`这个js文件`中是共享的，任何函数都可以访问。

## 局部作用域

- `局部作用域`，顾名思义，就是代表**只作用在某一块区域内**，在`局部作用域`定义的内容，**只在这一区域可以访问，外部无法访问局部作用域**。
- `局部作用域`也可以成为`函数作用域`，一般在`调用函数`的时候生成`局部作用域`，局部作用域中的内容，在`函数调用完成后`销毁。
- **每调用一次函数**就会创建一个**新的函数作用域**，它们之间是**相互独立的**。

```js
var b = "全局";

function test() {
  var a = 123;
  console.log(a);
}

function test1() {
  console.log(b);
  console.log(a);
}

test(); // 123  '全局'
test1(); // '全局'  a is not defined
```

上述代码我们可以看出，在`函数外部`定义**全局变量 b**，在`函数test内部`定义**局部变量 a**，结果 b 可以同时被 test 和 test1 所访问，而 a 只能被 test 所访问，就是因为**变量 a 处于函数 test 的局部作用域中，外部无法访问**。

为什么在函数 test1 中我们先打印 b 再打印 a 呢？这是因为`js是单线程的`，如果我们先打印 a，而找不到 a，就会抛出异常，停止执行下面的代码，我们的 b 就打印不出来了。

## 块级作用域

- 为了解决 ES5 中，变量提升，导致**内部变量**覆盖**外部变量**的情况，ES6 中出现了新的**声明变量的方式**，就是开头我们所说的`let`和`const`。它们两个究竟能解决怎样的问题呢？我们来看以下代码：

```js
var a = 1;

function test() {
  console.log(a);
  if (true) {
    var a = 123;
    console.log(a);
  }
}

test(); //  ?
```

上述代码会打印出什么内容呢？很多人都会觉得是 1，或者是 123.其实并不是，上述代码会打印出**undefined 和 123**。为什么会打印出**undefined**呢？原因就是，当我们**执行 test 函数**的时候，**变量 a**会进行**变量提升**，这就意味着，在**函数 test 的内部会创建一块局部作用域**，此时**局部作用域中 var a = undefined**(变量提升的过程中并不会对 a 进行赋值，只有执行到 var a = 123 这一步时，才会进行赋值)。并且在**执行 log 函数**的时候，**局部作用域中的 a 还未进行赋值操作**，因此会打印出**undefined**，而在**if 语句里**，变量 a 已经进行了赋值操作，此时打印出的 a 为 123。

如果我们使用`let`或者`const`会怎样呢？

```js
var a = 1;

function test() {
  console.log(a);
  if (true) {
    let a = 123;
    // const a = 123
    console.log(a);
  }
}

test(); //  1   123
```

从上述代码我们可知，结果为**1 和 123**，这是因为，当我们使用`let`或者`const`声明变量时，**该变量只在块级作用域中生效**，什么是**块级作用域**呢？根据我的理解，我们可以简单理解为**括号包裹的内容**就形成一个块级作用域，比如**if 语句**,**for 循环**等。此时因为**let a**只在**块级作用域中生效**，因此**不会进行变量提升**，当我们执行**console.log(a)**的时候，因为**局部变量没有 a**，因此会去外层也就是**全局变量寻找**,于是就打印出了**全局变量的 a**。

## 作用域链

我们知道，**函数内部有自己的作用域**，因此**全局变量**和**局部变量**互不冲突，比如我们在**全局变量定义 a**，我们在**局部变量中也可以定义一个 a**，此时两个 a 并不冲突。如下代码：

```js
var a = "全局变量";

function test() {
  var a = "test内部变量";
  console.log(a);
}

function test1() {
  console.log(a);
}

test(); // test内部变量
test1(); // 全局变量
```

上述代码中，分别定义了`全局变量a`和`局部变量a`。当两个函数同时打印 a 时，有`局部变量a`的打印出了**局部变量的值**，没有`局部变量a`的则打印出来`全局变量a`的值，这是为什么呢？因为当`访问作用域中的内容时`，会先从**局部作用域中查找**，如果**局部作用域没有找到**，则会去**上一级的局部作用域**查找，直至**全局作用域**，这种逐级查找的方式就叫做**作用域链**。

我们再来看一个例子：

```js
var a = "全局变量";

function global() {
  console.log(a);
}

function test() {
  var a = "test内部变量";
  global();
}

test(); // 全局变量
```

这个示例中，可能有些人会认为打印出来的 a 会打印出**函数 test 的内部变量**，因为**global 函数是在 test 内部执行的**。但实际上并不是这样，我们不能看**函数在哪里执行**，而是要看**函数在哪里被定义**，上述代码中，因为**函数 global 定义在全局作用域**，因此访问**变量 a**的时候，首先会去自己的作用域，即**全局作用域**中寻找，所以会打印出**全局变量的 a**。
