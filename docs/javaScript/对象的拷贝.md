# 拷贝

::: tip
在我们学习对象拷贝之前，我们需要了解一下`对象`这个数据类型。我们知道`Object`在 **JavaScript** 中属于`引用数据类型`，
所谓`引用数据类型`就意味着 **每一个对象** 都是引用了 **内存中的一块地址**。每`定义一个新对象`都会在`内存中开辟一块新地址`。如下图所示：
:::
![obj](/img/对象的地址.jpg)

## 浅拷贝
当我们想`拷贝`一个和当前对象`一模一样的对象`的时候，我们首先想到的就是，让`新对象=旧对象`，但是从图片我们可以知道，`对象`引用的是内存地址，当我们给`新对象`赋值为`旧对象`的时候，其实是把`新对象的指针`**指向**了`旧的对象`。相当于两个对象共用一块内存地址。因此，有一方改变数据的时候，`任何指向该地址的对象`的数据都会发生改变。而这种`看似拷贝`，实际上没有改变`引用地址`的拷贝方式，我们称之为`浅拷贝`。
```js
let obj = {} // 此时会开辟一块内存地址，假设该地址为a   对象obj的指针指向a

let obj1 = obj // 此时，创建了一个新的对象，并将该对象的指针也指向a，看似拥有和obj一样的属性和方法，其实不过是和obj用的一套罢了。

obj.num = 666 // 给对象obj添加属性 num = 666

console.log(obj1.num) // 打印出obj1也有num属性，且也为666

obj1.num = 888  // 当我们给obj1改变num的值时，我们预期obj.num的值还是666，因为我们不希望两个对象互想影响

console.log(obj.num)  // 打印出888，说明两个对象的属性方法是会互相影响的
```

这种`只拷贝对象内容`而不`开辟新的内存地址`的拷贝方式我们称之为 **浅拷贝**。
**浅拷贝** 常见的方式有：
1. 引用赋值 2. Object.assign()

::: tip
Object.assign(obj1,obj2)，该方法允许我们传入两个对象参数，会帮我们把 **obj1** 和 **obj2** 两个对象中的属性进行合并，如果 **obj1**和 **obj2** 中共同存在的属性，会被 **obj2** 覆盖，没有的则会新增。该方法最终会把obj1当作返回值。
该方法如果拷贝的对象只有一级属性，即对象中没有对象，那么 **该方法就是深拷贝**，否则该方法就是 **浅拷贝**。
:::

```js
// 输入
let obj1 = {
  name: 'coder',
  age: 21,
  arr: [1,2,3]
}

let obj2 = {
  age: 18,
  arr: [1,2],
  fun: function(){}
}

let obj3 = Object.assign({},obj2)
console.log(obj3) // {age: 18, arr: Array(2), fun: ƒ} 实现了拷贝obj2
console.log(Object.assign(obj1,obj2)) // {name: "coder", age: 18, arr: Array(2), fun: ƒ}
console.log(obj1) // {name: "coder", age: 18, arr: Array(2), fun: ƒ}

obj3.age = 19
obj3.arr.pop()
console.log(obj2.age) // 18 一级属性未受影响
console.log(obj2.arr) // [1] 引用类型的属性受到了影响
```

## 深拷贝
通过`浅拷贝`我们可想而知，假如我们需要一个 **新的对象** ，但是我们不想修改 **新对象** 的时候让 **被拷贝** 的对象发生属性的改变，我们应该怎么做呢？这时候我们就需要采用`深拷贝`来进行对象的拷贝。所谓`深拷贝`就是在我们拷贝对象的时候，对那些`引用数据类型`的数据开辟新的内存空间，从而让两个对象 **互不影响**。

### 方法一：转JSON进行深拷贝
* 该方法只适用于可以转为 **JSON字符串** 的对象，如果对象中含有`function`或者`RegExp`就不能使用该方法

``` js
// 输入
let obj = {
  a: 1,
  b: 2,
  c: [1,2,3]
}

let jsonStr = JSON.stringify(obj) // 将对象转成JSON字符串

let obj1 = JSON.parse(jsonStr)

obj.c.pop()

console.log(obj.c) // [1,2] obj中的引用类型c改变了
console.log(obj1.a) // 1 拷贝成功
console.log(obj1.c) // [1,2,3] obj1中的引用类型c未改变，说明二者互不影响 深拷贝成功
```

### 方法二：封装deepClone方法
``` js
// 输入
function deepClone(obj) {
  // 如果参数的类型不是'object' 直接返回
  if (typeof(obj) !== 'object') return obj
  // 如果是object，判断是数组还是对象
  let newObj = obj instanceof Array ? [] : {}
  // 如果是object，则遍历对象的属性
  for (let key in obj) {
    // 如果该key是该对象的可枚举属性（防止拷贝原型上的数据）
    if (obj.hasOwnProperty(key)) {
      // 对新对象的key进行赋值
      newObj[key] = deepClone(obj[key])
    }
  }
  return newObj
}

// 测试
let obj1 = {
  a: 1,
  b: '2',
  c: function() {
    console.log('obj1')
  },
  d: [1,2,3]
}

let obj2 = deepClone(obj1)

obj1.d.pop()

console.log(obj1.d) // [1,2]
console.log(obj2.d) // [1,2,3]
console.log(obj2.a) // 1
console.log(obj2.b) // '2'
console.log(obj2.c) // f(){}
```
* 上述的拷贝代码，可以帮我们实现深拷贝。我们可以看到，`obj1`中的属性全部被 **拷贝** 到了 `obj2`中，且`obj1`中的引用类型哪怕发生改变，也不会影响`obj2`中引用类型的值。

::: tip
* 深浅拷贝没有谁好谁坏，根据自己的业务需求来选择自己需要进行`深拷贝`还是`浅拷贝`。
:::