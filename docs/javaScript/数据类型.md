# 数据类型

## 数据类型的种类

**JavaScript** 的数据类型可分为两种，分别为 **基本数据类型** 和 **引用数据类型**

### 基本数据类型

- 数字类型 `Number`

- 字符串类型 `String`

- undefined 型 `undefined`

- null 类型 `null`

- 布尔类型 `Boolean`

- 符号类型 `Symbol`

- BigInt 类型 `BigInt`

### 引用数据类型

对象类型 `Object`

::: tip

- BigInt 类型不能与 Number 类型进行相互转换，否则会抛出异常。

- JS 中，万物皆为对象，我们熟知的`Function`以及`Array`其实也是对象，而不是单独的数据类型，但有人喜欢把`Object`和`Function`平起平坐，这大部分原因是 typeof 可以检测出`Function`类型。
  :::

## 判断数据类型

::: warning
我们既然学习了 JS 基本的数据类型，当我们编写代码时如何判断当前数据的类型呢？
:::

### 简单类型的判断

在 JS 中，已经有方法可以判断简单的数据类型，该方法就是 `typeof`

接下来我们来看一段代码

```js
// 输入
const num = 123;
const str = "123";
const boo = true;
const fun = function () {};

console.log(typeof num);
console.log(typeof str);
console.log(typeof boo);
console.log(typeof fun);

// return number string boolean function
```

此时，我们定义了四个 **常量** 的值，当我们通过`typeof`来判断它的类型时，控制台分别给我们打印出了`number`、`string`、`boolean`、`function`，这说明`typeof`是可以帮助我们判断一些简单的数据类型，同时，`typeof`还可以帮我们判断`function`类型，这也是为什么很多人把`Function`也当作一种数据类型。

### 复杂类型的判断

简单的类型可以通过`typeof`方法来进行判断，那么如果是复杂的 **引用数据类型** 呢？

来看这段代码

```js
// 输入
const empty = null;

const obj = {
  name: "coder",
  age: "21",
};

const arr = [1, 2, 3, 4, 5];

console.log(typeof empty);
console.log(typeof obj);
console.log(typeof arr);

// return object
```

通过这段代码，我们可以发现，无论是`Array`还是`Object`,通过`typeof`来判断的结果都是`object`，甚至连 **基本数据类型** 的`null`也是`object`，这是为什么呢？

::: tip
首先我们应该知道`null`到底代表了什么。`null`其实代表了一个尚未存在的 **对象**，当把`null`转化为数值类型时，它的值是`0`，因此我们可以理解为，`null`代表了一个 **不确定的对象**，API 中，`null`接收的返回值通常为对象，这是`JavaScript`的历史遗留问题，我们无法控制，这样的话我们就可以理解为什么 `typeof(null)`会返回`object`了。
:::

而 **Array** 和 **Object** 的判断结果都是`object`我们就很好理解了，因为它们都是`引用数据类型`。那么我们在使用的过程中，如何区分这些数据类型呢？ 废话少说，上代码！

**首先是判断`Array`和`Object`两个**

```js
// 输入
const obj = {
  name: "coder",
  age: "21",
};

const arr = [1, 2, 3, 4, 5];

const date = new Date();

console.log(obj instanceof Array);
console.log(arr instanceof Array);
console.log(date instanceof Array);
console.log(obj instanceof Date);
console.log(arr instanceof Date);
console.log(date instanceof Date);
console.log(obj instanceof Object);
console.log(arr instanceof Object);
console.log(date instanceof Object);

// return false、true、false、false、false、true、true、true、true
```

`instanceof`是**JavaScript**内置的一种方法，它可以判断**某个变量的原型链上**是否出现了某个**构造函数对象**。

这样听起来有点拗口，我们只能用代码来解释下了:sob:

首先我们拿到 obj 的原型对象

```js
console.log(obj.__proto__); // return: {constructor:f Object(), ...}
// 继续直到返回null
console.log(obj.__proto__.__proto__); // return: null
```

我们可以通过以上方式拿到`arr`和`date`两个变量的原型链，我们可以分析它们`原型链上`每一次的`原型对象`，它们的原型链上分别出现了包含**Array、Object**和**Date、Object**构造函数的原型对象，所以当我们使用`instanceof`来判断时，如果是 Array，只有 arr 满足条件，如果是 Date，只有 date 满足，但如果是 Object，它们三个都满足，因为在它们的原型链上都有一个为**Object 构造函数**的属性:smirk:

**判断`null`、`Array`、`Object`三种**

```js
// 使用转字符串的方式进行判断

// 输入
const obj = {
  name: "coder",
  age: "21",
};

const empty = null;

const arr = [1, 2, 3, 4, 5];

console.log(Object.prototype.toString.call(obj));
console.log(Object.prototype.toString.call(empty));
console.log(Object.prototype.toString.call(arr));

// return [object Object]、[object Null]、[object Array]
```

为什么可以采用这种方法来进行判断呢？因为在 **Object** 的 **原型链** 上有`toString`方法，通过`call`来改变`this`的指向，通俗的说就是让**call**后边括号里的**变量**或者**常量**来调用`toString`方法，就会得到不同的结果，就可以来判断到底是什么类型啦。至于如何改变 this 的指向，我们后续再说。
